const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().split("\n");

const n = Number(input[0]);

//1을 만드려고 함

let d = new Array(n + 1).fill(0);


//최종적으로 n의 연산 횟수를 구하는 것이니 작은 문제로 보면 
// 10 - > 9 -> 3 -> 1 인데 총 3회의 연산을 이루어지는 것이고 , 
// 상향 식으로 보면 1 -> 3 -> 9 -> 10으로 보면 , 작은 문제서 부터 시작하면 이해가 빠르다.(dp 특성으로 작은문제부터)
//3은 3으로 나누어 떨어지니까 d[3] 1번의 연산이 이루어지는거니까 d[3]++ 으로 인해서 1번 이루어짐 
//2와 3으로 나누어떨어지지 않으면 계속 -1 연산을 해야하니 계속 스택으로 1을 누적 하고 한번씩 연산이 이루어지니까 
//9는 3으로 나누어 떨어지니 1번의 연산이 이루어지니까 d[9]에서 기존에 누적된 숫자보다 , d[3]에서 *3 한것이니나 마찬가지니 연산 d[3]횟수에서 +1;
//10은 9에서 1을 더한 것이니 d[9]에서 1회 더한것
for (let x = 2; x <= n; x++) {

    
  d[x] = d[x - 1];
  if (x % 2 == 0) {
    d[x] = Math.min(d[x], d[parseInt(x / 2)]);
  }
  if (x % 3 == 0) {
    d[x] = Math.min(d[x], d[parseInt(x / 3)]);
  }
  d[x]++;

}
console.log(d[n]);

//!chatGPT 이해
// 네, 맞습니다! 여러분의 해석은 정확하고 명료합니다. 주어진 설명을 바탕으로 상세하게 풀어보겠습니다.

// - `d[x]`는 `x`를 1로 만드는 최소 연산 횟수를 나타냅니다.

// 만약 `n`이 10이라고 해봅시다:

// 1. `d[1]`은 0입니다. (1은 이미 1이므로 추가 연산이 필요하지 않습니다.)
// 2. `d[2]`는 1입니다. (2를 1로 만들기 위해서 2로 나눕니다.)
// 3. `d[3]`는 1입니다. (3을 1로 만들기 위해서 3으로 나눕니다.)
// 4. `d[4]`는 2입니다. (4를 2로 나눈 후, 다시 2를 1로 만들기 위해서 2로 나눕니다.)
// ... (중략) ...
// 9. `d[9]`는 2입니다. (9를 3으로 나눈 결과는 3이고, 3을 1로 만들기 위해서 다시 3으로 나눕니다.)
// 10. `d[10]`는 `d[9] + 1 = 3`입니다. (10을 만들기 위한 최소 연산 횟수는 9에 1을 더하는 것입니다. 그렇기 때문에 9를 1로 만드는 최소 연산 횟수에 1을 더합니다.)

// 이렇게 각 `x`에 대해 가능한 연산 중 최소 연산 횟수를 계산하면서 `d[n]`을 구할 수 있습니다.

// 여러분이 서술한 과정으로 보면, 작은 숫자부터 시작하여 큰 숫자를 향해 연산 횟수를 계산하는 상향식 접근 방법으로 문제를 해결하였습니다.